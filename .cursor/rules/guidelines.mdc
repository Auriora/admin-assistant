---
description: 
globs: 
alwaysApply: true
---
# GPT AI Code Generation Guidelines

This file contains guidelines for AI-generated code in the `admin-assistant` project. All contributors and AI agents must adhere to these standards to ensure maintainability, clarity, and quality. This file must be updated as new requirements or conventions are established.

## General Principles
- **All classes must follow SOLID principles**: Ensure code is modular, extensible, and easy to maintain.
- **Accessibility**: Where applicable, ensure user-facing features are accessible.
- **Comprehensive documentation**: Every class, method, and function must include docstrings explaining its purpose, parameters, and return values.
- **Consistent naming conventions**: Use `snake_case` for variables and functions, `PascalCase` for classes, and `UPPER_CASE` for constants.
- **Documentation as code**: All code must be self-documenting and include comprehensive docstrings and comments where necessary.
- **Don't Repeat Yourself (DRY)**: Avoid code duplication by abstracting common functionality into reusable components, functions, and classes.
- **Error handling**: Implement robust error handling and logging. Avoid silent failures.
- **Extensibility**: Design code to be easily extended for future features.
- **No magic numbers or literals**: All such values must be defined as named constants with clear, descriptive names.
- **Performance awareness**: Write efficient code and avoid unnecessary computations or memory usage.
- **Prioritise Off-The-Shelf (OTS)**: Use established libraries and frameworks (like Flask, SQLAlchemy, etc.) rather than creating custom solutions when appropriate functionality already exists.
- **Security best practices**: Never log or expose sensitive information (e.g., credentials, tokens). Use environment variables for secrets.
- **Separation of concerns**: Keep business logic, data access, and presentation layers separate.
- **Single source of truth**: Avoid duplication of logic or configuration.
- **Testability**: Code should be written to facilitate unit and integration testing. Avoid hard-coded dependencies; use dependency injection where appropriate.
- **Type annotations**: All functions and methods must include type hints for parameters and return values.
- **Observability:** All new code must use OpenTelemetry for distributed tracing. Follow the guidelines in `docs/guidelines/logging.md` for best practices.

## Exception Handling
- All exceptions must be handled explicitly and logged with context.
- Use custom exceptions and exception chaining (`from e`).
- Never mask, suppress, or silently swallow errors.
- Add context to exceptions as they propagate (use `add_note` where available).
- Handle exceptions at the appropriate layer (repository, service, orchestration) and always test error scenarios.
- See [docs/guidelines/exception_handling.md](mdc:../docs/guidelines/exception_handling.md) for full guidance and examples.

## SRS and Design Alignment
- **All AI-generated code and documentation must align with the current Software Requirements Specification (SRS) in `docs/1-requirements/.**` and the design documentation in `docs/2-design/.**`
- The SRS defines the authoritative requirements, use cases, and constraints. The design documentation provides architectural, data model, and feature-specific design details. Any generated code must directly support and not contradict the SRS or design documentation.
- When the SRS or design documentation is updated, these guidelines and all generated code must be reviewed for continued compliance.

## Project-Specific Notes
- This file must be referenced in all AI code generation settings and updated as new requirements arise.
- All code must comply with Microsoft 365 API usage policies and data privacy requirements.

## Project Directory Structure & Frameworks
- The project uses the following structure:

```
admin-assistant/
│
├── app/
│   ├── __init__.py
│   ├── models.py         # SQLAlchemy models
│   ├── routes/
│   │   ├── __init__.py
│   │   └── main.py       # Flask routes/views
│   ├── services/
│   │   ├── __init__.py
│   │   └── ...           # Business logic modules
│   ├── templates/
│   │   └── ...           # Jinja2 HTML templates (Bootstrap)
│   ├── static/
│   │   ├── css/
│   │   │   └── bootstrap.min.css
│   │   └── js/
│   │       └── bootstrap.bundle.min.js
│   └── config.py         # Configuration (env, DB, etc.)
│
├── core/
│   ├── models/           # SQLAlchemy models for all domain entities
│   ├── repositories/     # Repository interfaces and implementations (multiple backends)
│   ├── stores/           # Store abstractions for CRUD operations (SQLAlchemy, MS Graph, etc.)
│   ├── services/         # Business/domain logic (calendar, recurrence, overlap, etc.)
│   └── ...               # Other core modules
│
├── tests/
│   ├── __init__.py
│   └── test_basic.py     # Pytest starter
│
├── migrations/           # For Alembic/Flask-Migrate (optional, for DB migrations)
│
├── .env                  # Environment variables (not committed)
├── .gitignore
├── requirements.txt
├── run.py                # Entry point for Flask app
│
└── docs/                 # Documentation
```

- **Flask** is used as the web framework, following the application factory pattern for modularity and testability.
- **Bootstrap** is used for responsive UI, included in the `static/` and `templates/` folders.
- **SQLAlchemy** is used for ORM, with models defined in `app/models.py` and `core/models/`.
- **Pytest** is used for testing, with tests in the `tests/` directory.
- **SQLite** is the default development database, configurable via `app/config.py`.
- **core/** encapsulates all business logic, domain models, and data access abstractions, supporting extensibility and maintainability.

## Core Layer and Data Access Guidelines
- All business logic, domain models, and data access abstractions must reside in the `core/` directory.
- Use the **Repository Pattern** to abstract data access for each domain entity. Define a base repository interface and provide concrete implementations for each backend (e.g., SQLAlchemy, Microsoft Graph API).
- Use the **Store Pattern** for generic CRUD operations, enabling code reuse and further abstraction of the data access layer.
- Use the **Factory Pattern** to instantiate the appropriate repository or store implementation based on configuration or runtime context.
- The web layer (Flask) must interact only with core services and repositories, never directly with the database or external APIs.
- All business logic, validation, and data transformation must be handled in the `core/` layer, ensuring testability and extensibility.
- New data backends (e.g., REST APIs, other databases) should be added by implementing the repository and/or store interfaces, without modifying business logic.
- All code in `core/` must follow SOLID principles, be fully type-annotated, and include comprehensive docstrings.

## Migration and Shell Guidelines
- Always prefer **Bash** over PowerShell for running shell commands, unless specifically instructed otherwise. PowerShell is known to cause issues with interactive and some non-interactive commands on Linux (see recent pytest failures). Use Bash for all development, testing, and migration shell commands.
- For 'core/' database migrations, use Alembic.
- For Flask database migrations, use Flask-Migrate (`flask db` commands) instead of direct Alembic commands.

**Best Practice: Never modify an existing Alembic migration after it has been run/applied to any environment.**
- Always create a new migration file for any schema change (e.g., adding a new column).
- Never edit or append schema changes to an already-applied migration.
- This preserves migration integrity and avoids database inconsistencies or migration failures.

## AI Agent Operational Best Practices

- **Tool-Driven Exploration:** Always use available codebase exploration tools (semantic search, file search, directory listing, etc.) to gather information before making assumptions or generating code.
- **Minimal and Contextual Edits:** When editing files, specify only the minimal code necessary for the change, using context markers to avoid accidental code removal. Never output unchanged code unless necessary for context.
- **Error Handling:** Attempt to fix linter or syntax errors if the solution is clear. After three unsuccessful attempts, escalate to the user.
- **Command Line Usage:** Use non-interactive flags for shell commands and avoid commands requiring user interaction unless instructed. Run long-running jobs in the background.
- **Query Focus:** When a <most_important_user_query> is present, treat it as the authoritative query and ignore previous queries.
- **Clarification:** Always ask clarifying questions if requirements are ambiguous. Prefer tool-based discovery over user queries when possible.
- **Process Transparency:** Justify all actions taken and explain them in the context of the user's request.
- **Security:** Never output, log, or expose sensitive information in any user-facing message or code output.
- **Documentation Consistency:** Always update `.cursor/rules/guidelines.mdc` (this file) when asked to update AI Guidelines to ensure documentation remains current and consistent.
- **Command Output Analysis:** Read command output thoroughly to the end before interpreting results. Avoid making premature assumptions about errors or success states. Always verify the exact location and nature of issues by analyzing the complete output rather than jumping to conclusions based on partial information.


---
_Last updated: [2025-05-27]_